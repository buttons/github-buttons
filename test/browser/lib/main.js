// Generated by CoffeeScript 1.10.0
(function() {
  var ButtonAnchor, ButtonFrame, ButtonFrameContent, Config, Element, EventTarget, FlatObject, Frame, Hash, QueryString, base1,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  FlatObject = (function() {
    var index;

    function FlatObject() {}

    FlatObject.flatten = function(obj) {
      var flatten, result;
      flatten = function(object, flat_key) {
        var index, item, j, key, len, value;
        switch (Object.prototype.toString.call(object)) {
          case "[object Object]":
            for (key in object) {
              value = object[key];
              flatten(value, flat_key ? flat_key + "." + key : key);
            }
            break;
          case "[object Array]":
            for (index = j = 0, len = object.length; j < len; index = ++j) {
              item = object[index];
              flatten(item, flat_key + "[" + index + "]");
            }
            break;
          default:
            result[flat_key] = object;
        }
      };
      result = {};
      flatten(obj, "");
      return result;
    };

    FlatObject.expand = function(obj) {
      var flat_key, key, keys, namespace, target, value;
      namespace = [];
      for (flat_key in obj) {
        value = obj[flat_key];
        keys = flat_key.match(/((?!\[\d+\])[^.])+|\[\d+\]/g);
        target = namespace;
        key = 0;
        while (keys.length) {
          if (target[key] == null) {
            target[key] = keys[0] === index(keys[0]) ? {} : [];
          }
          target = target[key];
          key = index(keys.shift());
        }
        target[key] = value;
      }
      return namespace[0];
    };

    index = function(str) {
      var match;
      if (match = str.match(/^\[(\d+)\]$/)) {
        return Number(match[1]);
      } else {
        return str;
      }
    };

    return FlatObject;

  })();

  QueryString = (function() {
    function QueryString() {}

    QueryString.stringify = function(obj) {
      var key, results, value;
      results = [];
      for (key in obj) {
        value = obj[key];
        results.push(key + "=" + (value != null ? value : ""));
      }
      return results.join("&");
    };

    QueryString.parse = function(str) {
      var j, key, len, obj, pair, ref, ref1, value;
      obj = {};
      ref = str.split("&");
      for (j = 0, len = ref.length; j < len; j++) {
        pair = ref[j];
        if (!(pair !== "")) {
          continue;
        }
        ref1 = pair.split("="), key = ref1[0], value = 2 <= ref1.length ? slice.call(ref1, 1) : [];
        if (key !== "") {
          obj[key] = value.join("=");
        }
      }
      return obj;
    };

    return QueryString;

  })();

  Hash = (function() {
    function Hash() {}

    Hash.encode = function(data) {
      return "#" + encodeURIComponent(QueryString.stringify(FlatObject.flatten(data)));
    };

    Hash.decode = function(data) {
      if (data == null) {
        data = document.location.hash;
      }
      return (FlatObject.expand(QueryString.parse(decodeURIComponent(data.replace(/^#/, ""))))) || {};
    };

    return Hash;

  })();

  EventTarget = (function() {
    var addEventListener, removeEventListener;

    function EventTarget($) {
      this.$ = $;
    }

    EventTarget.prototype.get = function() {
      return this.$;
    };

    EventTarget.prototype.on = function() {
      var callback, eventName, events, func, j, k, len;
      events = 2 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 1) : (j = 0, []), func = arguments[j++];
      callback = (function(_this) {
        return function(event) {
          return func.call(_this, event || window.event);
        };
      })(this);
      for (k = 0, len = events.length; k < len; k++) {
        eventName = events[k];
        addEventListener(this.$, eventName, callback);
      }
    };

    EventTarget.prototype.once = function() {
      var callback, eventName, events, func, j, k, len;
      events = 2 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 1) : (j = 0, []), func = arguments[j++];
      callback = (function(_this) {
        return function(event) {
          var eventName, k, len;
          for (k = 0, len = events.length; k < len; k++) {
            eventName = events[k];
            removeEventListener(_this.$, eventName, callback);
          }
          return func.call(_this, event || window.event);
        };
      })(this);
      for (k = 0, len = events.length; k < len; k++) {
        eventName = events[k];
        addEventListener(this.$, eventName, callback);
      }
    };

    addEventListener = function(element, event, func) {
      if (element.addEventListener) {
        element.addEventListener("" + event, func);
      } else {
        element.attachEvent("on" + event, func);
      }
    };

    removeEventListener = function(element, event, func) {
      if (element.removeEventListener) {
        element.removeEventListener("" + event, func);
      } else {
        element.detachEvent("on" + event, func);
      }
    };

    return EventTarget;

  })();

  Element = (function(superClass) {
    var addClass, hasClass, r_whitespace, removeClass;

    extend(Element, superClass);

    function Element(element, callback) {
      this.$ = element && element.nodeType === 1 ? element : document.createElement(element);
      if (callback) {
        callback.call(this, this.$);
      }
    }

    Element.prototype.addClass = function(className) {
      if (!hasClass(this.$, className)) {
        addClass(this.$, className);
      }
    };

    Element.prototype.removeClass = function(className) {
      if (hasClass(this.$, className)) {
        removeClass(this.$, className);
      }
    };

    Element.prototype.hasClass = function(className) {
      return hasClass(this.$, className);
    };

    addClass = function(element, className) {
      element.className += " " + className;
    };

    removeClass = function(element, className) {
      element.className = (" " + element.className + " ").replace(r_whitespace, " ").replace(" " + className + " ", "").replace(/^ | $/, "");
    };

    hasClass = function(element, className) {
      return (" " + element.className + " ").replace(r_whitespace, " ").indexOf(" " + className + " ") >= 0;
    };

    r_whitespace = /[ \t\n\f\r]+/g;

    return Element;

  })(EventTarget);

  Frame = (function(superClass) {
    var devicePixelRatio, roundPixel;

    extend(Frame, superClass);

    function Frame(callback) {
      Frame.__super__.constructor.call(this, "iframe", function(iframe) {
        var key, ref, ref1, value;
        ref = {
          allowtransparency: true,
          scrolling: "no",
          frameBorder: 0
        };
        for (key in ref) {
          value = ref[key];
          iframe.setAttribute(key, value);
        }
        ref1 = {
          border: "none",
          height: "0",
          width: "1px"
        };
        for (key in ref1) {
          value = ref1[key];
          iframe.style[key] = value;
        }
        if (callback) {
          callback.call(this, iframe);
        }
      });
    }

    Frame.prototype.html = function(html) {
      var contentDocument;
      try {
        contentDocument = this.$.contentWindow.document;
        contentDocument.open();
        contentDocument.write(html);
        contentDocument.close();
      } catch (undefined) {}
    };

    Frame.prototype.load = function(src) {
      this.$.src = src;
    };

    Frame.prototype.size = function() {
      var body, boundingClientRect, contentDocument, height, html, width;
      try {
        contentDocument = this.$.contentWindow.document;
        html = contentDocument.documentElement;
        body = contentDocument.body;
        html.style.overflow = body.style.overflow = window.opera ? "scroll" : "visible";
        width = body.scrollWidth;
        height = body.scrollHeight;
        if (body.getBoundingClientRect) {
          body.style.display = "inline-block";
          boundingClientRect = body.getBoundingClientRect();
          width = Math.max(width, roundPixel(boundingClientRect.width));
          height = Math.max(height, roundPixel(boundingClientRect.height));
          body.style.display = "";
        }
        html.style.overflow = body.style.overflow = "";
        return {
          width: width + "px",
          height: height + "px"
        };
      } catch (undefined) {}
    };

    Frame.prototype.resize = function(arg) {
      var height, ref, width;
      ref = arg != null ? arg : this.size() || {}, width = ref.width, height = ref.height;
      if (width) {
        this.$.style.width = width;
      }
      if (height) {
        this.$.style.height = height;
      }
    };

    devicePixelRatio = window.devicePixelRatio || 1;

    roundPixel = function(px) {
      if (devicePixelRatio > 1) {
        return Math.ceil(Math.round(px * devicePixelRatio) / devicePixelRatio * 2) / 2 || 0;
      } else {
        return Math.ceil(px);
      }
    };

    return Frame;

  })(Element);

  ButtonAnchor = (function() {
    function ButtonAnchor() {}

    ButtonAnchor.parse = function(element) {
      var api, icon, label, style;
      return {
        href: element.href,
        text: element.getAttribute("data-text") || element.textContent || element.innerText || "",
        data: {
          count: {
            api: (api = element.getAttribute("data-count-api")) && (~api.indexOf("#")) ? api.replace(/^(?!\/)/, "/") : void 0,
            href: element.getAttribute("data-count-href") || element.href,
            aria: {
              label: (label = element.getAttribute("data-count-aria-label")) ? label : void 0
            }
          },
          style: (style = element.getAttribute("data-style")) ? style : void 0,
          icon: (icon = element.getAttribute("data-icon")) ? icon : void 0
        },
        aria: {
          label: (label = element.getAttribute("aria-label")) ? label : void 0
        }
      };
    };

    return ButtonAnchor;

  })();

  ButtonFrame = (function(superClass) {
    extend(ButtonFrame, superClass);

    function ButtonFrame(hash, callback, onload) {
      var reload;
      ButtonFrame.__super__.constructor.call(this, callback);
      reload = (function(_this) {
        return function() {
          var size;
          size = _this.size();
          _this.once("load", function() {
            this.resize(size);
            if (onload) {
              onload.call(this, this.$);
            }
          });
          _this.load(Config.url + "buttons.html" + hash);
        };
      })(this);
      this.once("load", function() {
        if (callback = this.$.contentWindow.callback) {
          new Element(callback.script, function(script) {
            this.on("load", "error", reload);
            if (script.readyState) {
              this.on("readystatechange", function() {
                if (!/i/.test(script.readyState)) {
                  reload();
                }
              });
            }
          });
        } else {
          reload();
        }
      });
      this.html("<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title></title>\n<base target=\"_blank\"><!--[if lte IE 6]></base><![endif]-->\n<link rel=\"stylesheet\" href=\"" + Config.url + "assets/css/buttons.css\">\n<script>document.location.hash = \"" + hash + "\";</script>\n</head>\n<body>\n<script src=\"" + Config.script.src + "\"></script>\n</body>\n</html>");
    }

    return ButtonFrame;

  })(Frame);

  ButtonFrameContent = (function() {
    var Button, Count, r_javascript;

    function ButtonFrameContent(options) {
      var base;
      if (options && options.data) {
        document.body.className = options.data.style || "";
        base = document.getElementsByTagName("base")[0];
        if (options.href) {
          base.href = options.href;
        }
        if (r_javascript.test(base.href)) {
          base.href = options.href = options.data.count.href = "#";
        }
        new Button(options, function(buttonElement) {
          document.body.appendChild(buttonElement);
        });
        new Count(options.data.count, function(countElement) {
          document.body.appendChild(countElement);
        });
        base.removeAttribute("href");
      }
    }

    Button = (function(superClass) {
      extend(Button, superClass);

      function Button(options, callback) {
        Button.__super__.constructor.call(this, "a", function(a) {
          a.className = "button";
          if (options.href) {
            a.href = options.href;
          }
          if (r_javascript.test(a.href)) {
            a.href = "#";
          }
          if ("#" === a.getAttribute("href")) {
            a.target = "_self";
          }
          a.href = a.cloneNode().href;
          if (options.aria.label) {
            a.setAttribute("aria-label", options.aria.label);
          }
          new Element("i", function(icon) {
            icon = document.createElement("i");
            icon.className = (options.data.icon || Config.icon) + (Config.iconClass ? " " + Config.iconClass : "");
            icon.setAttribute("aria-hidden", "true");
            a.appendChild(icon);
          });
          new Element("span", function(text) {
            text.appendChild(document.createTextNode(" "));
            a.appendChild(text);
          });
          new Element("span", function(text) {
            if (options.text) {
              text.appendChild(document.createTextNode(options.text));
            }
            a.appendChild(text);
          });
          if (callback) {
            callback(a);
          }
        });
      }

      return Button;

    })(Element);

    Count = (function(superClass) {
      extend(Count, superClass);

      function Count(options, callback) {
        if (options && options.api) {
          Count.__super__.constructor.call(this, "a", function(a) {
            a.className = "count";
            if (options.href) {
              a.href = options.href;
            }
            if (r_javascript.test(a.href)) {
              a.href = "#";
            }
            if ("#" === a.getAttribute("href")) {
              a.target = "_self";
            }
            a.href = a.cloneNode().href;
            new Element("b", function(b) {
              a.appendChild(b);
            });
            new Element("i", function(i) {
              a.appendChild(i);
            });
            new Element("span", function(span) {
              var endpoint;
              a.appendChild(span);
              endpoint = (function() {
                var query, url;
                url = options.api.split("#")[0];
                query = QueryString.parse(url.split("?").slice(1).join("?"));
                query.callback = "callback";
                return (url.split("?")[0]) + "?" + (QueryString.stringify(query));
              })();
              new Element("script", function(script) {
                var head;
                script.async = true;
                script.src = "" + Config.api + endpoint;
                window.callback = function(json) {
                  var data;
                  window.callback = null;
                  if (json.meta.status === 200) {
                    data = FlatObject.flatten(json.data)[options.api.split("#").slice(1).join("#")];
                    if ("[object Number]" === Object.prototype.toString.call(data)) {
                      data = ("" + data).replace(/\B(?=(\d{3})+(?!\d))/g, ",");
                    }
                    span.appendChild(document.createTextNode(" " + data + " "));
                    if (options.aria.label) {
                      a.setAttribute("aria-label", options.aria.label.replace("#", data));
                    }
                    if (callback) {
                      callback(a);
                    }
                  }
                };
                window.callback.script = script;
                this.on("error", function() {
                  window.callback = null;
                });
                if (script.readyState) {
                  this.on("readystatechange", function() {
                    if (script.readyState === "loaded" && script.children && script.readyState === "loading") {
                      window.callback = null;
                    }
                  });
                }
                head = document.getElementsByTagName("head")[0];
                head.insertBefore(script, head.firstChild);
              });
            });
          });
        }
      }

      return Count;

    })(Element);

    r_javascript = /^javascript:/i;

    return ButtonFrameContent;

  })();

  if (window._phantom) {
    (base1 = HTMLElement.prototype).click || (base1.click = function() {
      var event;
      event = document.createEvent('MouseEvents');
      event.initMouseEvent('click', true, true, window, null, 0, 0, 0, 0, false, false, false, false, 0, null);
      this.dispatchEvent(event);
    });
  }

  Config = {
    api: "https://api.github.com",
    anchorClass: "github-button",
    iconClass: "octicon",
    icon: "octicon-mark-github",
    scriptId: "github-bjs",
    script: {
      src: "../../buttons.js"
    },
    url: "../../"
  };

  describe('Element', function() {
    describe('#constructor()', function() {
      it('should use element when element is given', function() {
        var element;
        element = document.createElement("a");
        return expect(new Element(element).get()).to.equal(element);
      });
      it('should create new element when tag name is given', function() {
        return expect(new Element("i").get().nodeType).to.equal(1);
      });
      it('should callback with this', function() {
        var _, _this;
        _this = null;
        _ = new Element("em", function(element) {
          return _this = this;
        });
        return expect(_this).to.equal(_);
      });
      return it('should callback with argument element', function(done) {
        var b;
        b = document.createElement("b");
        return new Element(b, function(element) {
          expect(element).to.equal(b);
          return done();
        });
      });
    });
    describe('#on()', function() {
      var input;
      input = null;
      beforeEach(function() {
        return input = new Element("input", function(element) {
          return document.body.appendChild(element);
        });
      });
      afterEach(function() {
        return document.body.removeChild(input.get());
      });
      it('should call the function on single event type', function() {
        var spy;
        spy = sinon.spy();
        input.on("click", spy);
        input.get().click();
        expect(spy).to.have.been.calledOnce;
        input.get().click();
        return expect(spy).to.have.been.calledTwice;
      });
      it('should call the function on multiple event types', function() {
        var spy;
        spy = sinon.spy();
        input.on("focus", "blur", "click", spy);
        input.get().focus();
        expect(spy).to.have.been.calledOnce;
        input.get().blur();
        expect(spy).to.have.been.calledTwice;
        input.get().click();
        return expect(spy).to.have.been.calledThrice;
      });
      it('should call the function with this', function(done) {
        var _this, a;
        a = document.createElement("a");
        _this = new Element(a);
        _this.on("click", function() {
          expect(this).to.equal(_this);
          return done();
        });
        return a.click();
      });
      return it('should call the function with event', function(done) {
        var b;
        b = document.createElement("b");
        new Element(b).on("click", function(event) {
          expect(event.type).to.equal("click");
          return done();
        });
        return b.click();
      });
    });
    describe('#once()', function() {
      var input;
      input = null;
      beforeEach(function() {
        return input = new Element("input", function(element) {
          return document.body.appendChild(element);
        });
      });
      afterEach(function() {
        return document.body.removeChild(input.get());
      });
      it('should call the function on single event type only once', function() {
        var spy;
        spy = sinon.spy();
        input.once("click", spy);
        input.get().click();
        expect(spy).to.have.been.calledOnce;
        input.get().click();
        input.get().click();
        return expect(spy).to.have.been.calledOnce;
      });
      it('should call the function on multiple event types only once', function() {
        var spy;
        spy = sinon.spy();
        input.once("focus", "blur", spy);
        input.get().focus();
        expect(spy).to.have.been.calledOnce;
        input.get().blur();
        input.get().focus();
        return expect(spy).to.have.been.calledOnce;
      });
      it('should call the function with this', function(done) {
        var _this, a;
        a = document.createElement("a");
        _this = new Element(a);
        _this.once("click", function() {
          expect(this).to.equal(_this);
          return done();
        });
        return a.click();
      });
      return it('should call the function with event', function(done) {
        var b;
        b = document.createElement("b");
        new Element(b).once("click", function(event) {
          expect(event.type).to.equal("click");
          return done();
        });
        return b.click();
      });
    });
    describe('#addClass()', function() {
      return it('should add class to element', function() {
        var a, element;
        element = document.createElement("a");
        element.className = "hello";
        a = new Element(element);
        a.addClass("world");
        expect(a.get().className).to.equal("hello world");
        a.addClass("world");
        return expect(a.get().className).to.equal("hello world");
      });
    });
    describe('#removeClass()', function() {
      return it('should remove class from element', function() {
        var a, element;
        element = document.createElement("a");
        element.className = "hello world";
        a = new Element(element);
        a.removeClass("hello");
        expect(a.get().className).to.equal("world");
        a.removeClass("hello");
        return expect(a.get().className).to.equal("world");
      });
    });
    return describe('#hasClass()', function() {
      return it('should return whether element has class', function() {
        var a, element;
        element = document.createElement("a");
        element.className = "world";
        a = new Element(element);
        expect(a.hasClass("hello")).to.be["false"];
        return expect(a.hasClass("world")).to.be["true"];
      });
    });
  });

  describe('Frame', function() {
    var frame, html;
    frame = null;
    html = "<!DOCTYPE html>\n<html lang=\"ja\">\n<head>\n  <meta charset=\"utf-8\">\n  <title></title>\n</head>\n<body style=\"margin: 0;\">\n  <div style=\"width: 200.5px; height: 100px;\"></div>\n</body>\n</html>";
    beforeEach(function() {
      return frame = new Frame(function(iframe) {
        return document.body.appendChild(iframe);
      });
    });
    afterEach(function() {
      return document.body.removeChild(frame.get());
    });
    describe('#constructor()', function() {
      return it('should callback with the new iframe', function() {
        expect(frame.get().nodeType).to.equal(1);
        return expect(frame.get().tagName).to.equal("IFRAME");
      });
    });
    describe('#html()', function() {
      return it('should write html when iframe is in same-origin', function(done) {
        frame.on("load", function() {
          expect(frame.get().contentWindow.document.documentElement.getAttribute("lang")).to.equal("ja");
          return done();
        });
        return frame.html(html);
      });
    });
    describe('#load()', function() {
      return it('should load the src url', function() {
        frame.load("../../buttons.html");
        return expect(frame.get().src).to.match(/buttons\.html$/);
      });
    });
    describe('#size()', function() {
      return it('should return the iframe content size', function(done) {
        frame.on("load", function() {
          switch (window.devicePixelRatio) {
            case 2:
              expect(this.size()).to.deep.equal({
                width: "200.5px",
                height: "100px"
              });
              break;
            case 3:
              expect(this.size()).to.deep.equal({
                width: "201px",
                height: "100px"
              });
          }
          return done();
        });
        return frame.html(html);
      });
    });
    return describe('#resize()', function() {
      return it('should resize the iframe', function(done) {
        frame.resize({
          width: "20px",
          height: "10px"
        });
        expect(frame.get().style.width).to.equal("20px");
        expect(frame.get().style.height).to.equal("10px");
        return done();
      });
    });
  });

  describe('ButtonAnchor', function() {
    var a;
    a = null;
    beforeEach(function() {
      return a = document.createElement("a");
    });
    return describe('.parse()', function() {
      it('should parse the anchor without attribute', function() {
        return expect(ButtonAnchor.parse(a)).to.deep.equal({
          href: "",
          text: "",
          data: {
            count: {
              api: void 0,
              href: "",
              aria: {
                label: void 0
              }
            },
            style: void 0,
            icon: void 0
          },
          aria: {
            label: void 0
          }
        });
      });
      it('should parse the attribute href', function() {
        a.href = "https://buttons.github.io/";
        return expect(ButtonAnchor.parse(a)).to.have.property("href").and.equal(a.href);
      });
      it('should parse the attribute data-text', function() {
        var text;
        text = "test";
        a.setAttribute("data-text", text);
        return expect(ButtonAnchor.parse(a)).to.have.property("text").and.equal(text);
      });
      it('should parse the text content', function() {
        var text;
        text = "something";
        a.appendChild(document.createTextNode(text));
        return expect(ButtonAnchor.parse(a)).to.have.property("text").and.equal(text);
      });
      it('should ignore the text content when the attribute data-text is given', function() {
        var text;
        text = "something";
        a.setAttribute("data-text", text);
        a.appendChild(document.createTextNode("something else"));
        return expect(ButtonAnchor.parse(a)).to.have.property("text").and.equal(text);
      });
      it('should parse the attribute data-count-api', function() {
        var api;
        api = "/repos/:user/:repo#item";
        a.setAttribute("data-count-api", api);
        return expect(ButtonAnchor.parse(a)).to.have.deep.property("data.count.api").and.equal(api);
      });
      it('should prepend / when the attribute data-count-api does not start with /', function() {
        var api;
        api = "repos/:user/:repo#item";
        a.setAttribute("data-count-api", api);
        return expect(ButtonAnchor.parse(a)).to.have.deep.property("data.count.api").and.equal("/" + api);
      });
      it('should ignore the attribute data-count-api when missing #', function() {
        var api;
        api = "/repos/:user/:repo";
        a.setAttribute("data-count-api", api);
        return expect(ButtonAnchor.parse(a)).to.have.deep.property("data.count.api").and.be.undefined;
      });
      it('should parse the attribute data-count-href', function() {
        var href;
        href = "https://github.com/";
        a.setAttribute("data-count-href", href);
        return expect(ButtonAnchor.parse(a)).to.have.deep.property("data.count.href").and.equal(href);
      });
      it('should fallback data.cout.href to the attribute href when the attribute data-count-href is not given', function() {
        a.href = "https://github.com/";
        return expect(ButtonAnchor.parse(a)).to.have.deep.property("data.count.href").and.equal(a.href);
      });
      it('should parse the attribute data-style', function() {
        var style;
        style = "mega";
        a.setAttribute("data-style", style);
        return expect(ButtonAnchor.parse(a)).to.have.deep.property("data.style").and.equal(style);
      });
      return it('should parse the attribute data-icon', function() {
        var icon;
        icon = "octicon";
        a.setAttribute("data-icon", icon);
        return expect(ButtonAnchor.parse(a)).to.have.deep.property("data.icon").and.equal(icon);
      });
    });
  });

  describe('ButtonFrame', function() {
    return describe('#constructor()', function() {
      var hash;
      hash = Hash.encode(ButtonAnchor.parse(document.createElement("a")));
      it('should callback with this twice', function(done) {
        var _, _this;
        _this = null;
        return _ = new ButtonFrame(hash, function(iframe) {
          document.body.appendChild(iframe);
          return _this = this;
        }, function(iframe) {
          expect(_this).to.equal(_);
          expect(this).to.equal(_);
          iframe.parentNode.removeChild(iframe);
          return done();
        });
      });
      it('should callback with the iframe as argument twice', function(done) {
        var frame;
        frame = null;
        return new ButtonFrame(hash, function(iframe) {
          document.body.appendChild(iframe);
          frame = iframe;
          return expect(iframe.tagName).to.equal("IFRAME");
        }, function(iframe) {
          expect(iframe).to.equal(frame);
          iframe.parentNode.removeChild(iframe);
          return done();
        });
      });
      it('should load the iframe twice after insert it into DOM', function(done) {
        var spy;
        spy = sinon.spy();
        return new ButtonFrame(hash, function(iframe) {
          document.body.appendChild(iframe);
          return this.on("load", function() {
            return spy();
          });
        }, function(iframe) {
          expect(spy).to.have.been.calledTwice;
          iframe.parentNode.removeChild(iframe);
          return done();
        });
      });
      it('should load the iframe the first time by writing html', function(done) {
        return new ButtonFrame(hash, function(iframe) {
          document.body.appendChild(iframe);
          return sinon.spy(this, "html");
        }, function(iframe) {
          expect(this.html).to.have.been.calledOnce;
          this.html.restore();
          iframe.parentNode.removeChild(iframe);
          return done();
        });
      });
      it('should set document.location.hash when load the first time by writing html', function(done) {
        var _hash;
        _hash = null;
        return new ButtonFrame(hash, function(iframe) {
          document.body.appendChild(iframe);
          return this.once("load", function() {
            return _hash = iframe.contentWindow.document.location.hash;
          });
        }, function(iframe) {
          expect(_hash).to.equal(hash);
          iframe.parentNode.removeChild(iframe);
          return done();
        });
      });
      it('should load the iframe the second time by setting the src attribute', function(done) {
        return new ButtonFrame(hash, function(iframe) {
          document.body.appendChild(iframe);
          sinon.spy(this, "html");
          return sinon.spy(this, "load");
        }, function(iframe) {
          expect(this.load).to.have.been.calledOnce;
          expect(this.load).to.have.been.calledAfter(this.html);
          this.html.restore();
          this.load.restore();
          iframe.parentNode.removeChild(iframe);
          return done();
        });
      });
      it('should set document.location.href when load the second time by setting the src attribute', function(done) {
        return new ButtonFrame(hash, function(iframe) {
          return document.body.appendChild(iframe);
        }, function(iframe) {
          expect(iframe.contentWindow.document.location.hash).to.equal(hash);
          iframe.parentNode.removeChild(iframe);
          return done();
        });
      });
      return it('should resize the iframe after the second load', function(done) {
        return new ButtonFrame(hash, function(iframe) {
          document.body.appendChild(iframe);
          sinon.spy(this, "html");
          sinon.spy(this, "load");
          sinon.spy(this, "size");
          return sinon.spy(this, "resize");
        }, function(iframe) {
          expect(this.size).to.have.been.calledOnce;
          expect(this.size).to.have.been.calledAfter(this.html);
          expect(this.resize).to.have.been.calledOnce;
          expect(this.resize).to.have.been.calledAfter(this.load);
          expect(this.resize.args[0][0]).to.deep.equal(this.size.returnValues[0]);
          expect(iframe.style.width).to.equal(this.size.returnValues[0].width);
          expect(iframe.style.height).to.equal(this.size.returnValues[0].height);
          this.html.restore();
          this.load.restore();
          this.size.restore();
          this.resize.restore();
          iframe.parentNode.removeChild(iframe);
          return done();
        });
      });
    });
  });

  describe('ButtonFrameContent', function() {
    var base, bodyClassName, data, head, javascript_protocals;
    head = document.getElementsByTagName("head")[0];
    base = null;
    bodyClassName = null;
    data = {
      "meta": {
        "X-RateLimit-Limit": "60",
        "X-RateLimit-Remaining": "59",
        "X-RateLimit-Reset": "1423391706",
        "Cache-Control": "public, max-age=60, s-maxage=60",
        "Last-Modified": "Sun, 08 Feb 2015 07:39:11 GMT",
        "Vary": "Accept",
        "X-GitHub-Media-Type": "github.v3",
        "status": 200
      },
      "data": {
        "login": "ntkme",
        "id": 899645,
        "avatar_url": "https://avatars.githubusercontent.com/u/899645?v=3",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ntkme",
        "html_url": "https://github.com/ntkme",
        "followers_url": "https://api.github.com/users/ntkme/followers",
        "following_url": "https://api.github.com/users/ntkme/following{/other_user}",
        "gists_url": "https://api.github.com/users/ntkme/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/ntkme/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/ntkme/subscriptions",
        "organizations_url": "https://api.github.com/users/ntkme/orgs",
        "repos_url": "https://api.github.com/users/ntkme/repos",
        "events_url": "https://api.github.com/users/ntkme/events{/privacy}",
        "received_events_url": "https://api.github.com/users/ntkme/received_events",
        "type": "User",
        "site_admin": false,
        "name": "なつき",
        "company": "",
        "blog": "https://ntk.me",
        "location": "California",
        "email": "i@ntk.me",
        "hireable": true,
        "bio": null,
        "public_repos": 10,
        "public_gists": 0,
        "followers": 26,
        "following": 0,
        "created_at": "2011-07-07T03:26:58Z",
        "updated_at": "2015-02-08T07:39:11Z"
      }
    };
    javascript_protocals = ["javascript:", "JAVASCRIPT:", "JavaScript:", " javascript:", "   javascript:", "\tjavascript:", "\njavascript:", "\rjavascript:", "\fjavascript:"];
    beforeEach(function() {
      bodyClassName = document.body.getAttribute("class");
      base = head.insertBefore(document.createElement("base"), head.firstChild);
      return sinon.stub(document.body, "appendChild");
    });
    afterEach(function() {
      if (bodyClassName) {
        document.body.className = bodyClassName;
      } else {
        document.body.removeAttribute("class");
      }
      base.parentNode.removeChild(base);
      return document.body.appendChild.restore();
    });
    return describe('#constructor()', function() {
      it('should do nothing when options are missing', function() {
        new ButtonFrameContent();
        expect(base.getAttribute("href")).to.be["null"];
        return expect(document.body.appendChild).to.have.not.been.called;
      });
      it('should not set base.href', function() {
        var options;
        options = {
          href: "https://github.com/",
          data: {},
          aria: {}
        };
        new ButtonFrameContent(options);
        return expect(base.getAttribute("href")).to.be["null"];
      });
      it('should set document.body.className when a style is given', function() {
        var options;
        options = {
          data: {
            style: "mega"
          },
          aria: {}
        };
        new ButtonFrameContent(options);
        return expect(document.body.className).to.equal(options.data.style);
      });
      it('should append the button to document.body when the necessary options are given', function() {
        var button, options;
        options = {
          data: {},
          aria: {}
        };
        new ButtonFrameContent(options);
        expect(document.body.appendChild).to.be.calledOnce;
        button = document.body.appendChild.args[0][0];
        return expect(button).to.have.property("className").and.equal("button");
      });
      it('should append the button with given href', function() {
        var button, options;
        options = {
          href: "https://twitter.com/",
          data: {},
          aria: {}
        };
        new ButtonFrameContent(options);
        button = document.body.appendChild.args[0][0];
        return expect(button.getAttribute("href")).to.equal(options.href);
      });
      it('should filter javascript in the href', function() {
        var button, href, i, j, len, options, results1;
        results1 = [];
        for (i = j = 0, len = javascript_protocals.length; j < len; i = ++j) {
          href = javascript_protocals[i];
          options = {
            href: href,
            data: {
              count: {
                href: href
              }
            },
            aria: {}
          };
          new ButtonFrameContent(options);
          button = document.body.appendChild.args[i][0];
          results1.push(expect(button.getAttribute("href")).to.not.match(/javascript:/i));
        }
        return results1;
      });
      it('should append the button with the default icon', function() {
        var button, options;
        options = {
          data: {},
          aria: {}
        };
        new ButtonFrameContent(options);
        button = document.body.appendChild.args[0][0];
        return expect((" " + button.firstChild.className + " ").indexOf(" " + Config.icon + " ")).to.be.at.least(0);
      });
      it('should append the button with given icon', function() {
        var button, options;
        options = {
          data: {
            icon: "octicon-star"
          },
          aria: {}
        };
        new ButtonFrameContent(options);
        button = document.body.appendChild.args[0][0];
        return expect((" " + button.firstChild.className + " ").indexOf(" " + options.data.icon + " ")).to.be.at.least(0);
      });
      it('should append the button with given text', function() {
        var button, options;
        options = {
          text: "Follow",
          data: {},
          aria: {}
        };
        new ButtonFrameContent(options);
        button = document.body.appendChild.args[0][0];
        return expect(button.lastChild.innerHTML).to.equal(options.text);
      });
      it('should append the button with given aria label', function() {
        var button, options;
        options = {
          data: {},
          aria: {
            label: "GitHub"
          }
        };
        new ButtonFrameContent(options);
        button = document.body.appendChild.args[0][0];
        return expect(button.getAttribute("aria-label")).to.equal(options.aria.label);
      });
      it('should append the count to document.body when the necessary options are given', function() {
        var count, options;
        sinon.stub(head, "insertBefore", function() {
          return window.callback(data);
        });
        options = {
          data: {
            count: {
              api: "/dummy/api#followers",
              aria: {}
            }
          },
          aria: {}
        };
        new ButtonFrameContent(options);
        expect(document.body.appendChild).to.be.calledTwice;
        count = document.body.appendChild.args[1][0];
        expect(count).to.have.property("className").and.equal("count");
        return head.insertBefore.restore();
      });
      it('should append the count with given data.count.href', function() {
        var count, options;
        sinon.stub(head, "insertBefore", function() {
          return window.callback(data);
        });
        options = {
          data: {
            count: {
              api: "/dummy/api#followers",
              href: "https://twitter.com/",
              aria: {}
            }
          },
          aria: {}
        };
        new ButtonFrameContent(options);
        count = document.body.appendChild.args[1][0];
        expect(count.getAttribute("href")).to.equal(options.data.count.href);
        return head.insertBefore.restore();
      });
      it('should append the count with #entry from api response', function() {
        var count, options;
        sinon.stub(head, "insertBefore", function() {
          return window.callback(data);
        });
        options = {
          data: {
            count: {
              api: "/dummy/api#followers",
              aria: {}
            }
          },
          aria: {}
        };
        new ButtonFrameContent(options);
        count = document.body.appendChild.args[1][0];
        expect(count.lastChild.innerHTML).to.equal(" 26 ");
        return head.insertBefore.restore();
      });
      it('should append the count with large number split by comma', function() {
        var count, options;
        sinon.stub(head, "insertBefore", function() {
          return window.callback(data);
        });
        options = {
          data: {
            count: {
              api: "/dummy/api#id",
              aria: {}
            }
          },
          aria: {}
        };
        new ButtonFrameContent(options);
        count = document.body.appendChild.args[1][0];
        expect(count.lastChild.innerHTML).to.equal(" 899,645 ");
        return head.insertBefore.restore();
      });
      it('should append the count with given aria label', function() {
        var count, options;
        sinon.stub(head, "insertBefore", function() {
          return window.callback(data);
        });
        options = {
          data: {
            count: {
              api: "/dummy/api#followers",
              aria: {
                label: "# followers on GitHub"
              }
            }
          },
          aria: {}
        };
        new ButtonFrameContent(options);
        count = document.body.appendChild.args[1][0];
        expect(count.getAttribute("aria-label")).to.equal("26 followers on GitHub");
        return head.insertBefore.restore();
      });
      it('should append the count with text undefined when api #entry does not exist', function() {
        var count, options;
        sinon.stub(head, "insertBefore", function() {
          return window.callback(data);
        });
        options = {
          data: {
            count: {
              api: "/dummy/api#fail",
              aria: {}
            }
          },
          aria: {}
        };
        new ButtonFrameContent(options);
        count = document.body.appendChild.args[1][0];
        expect(count.lastChild.innerHTML).to.equal(" undefined ");
        return head.insertBefore.restore();
      });
      return it('should not append the count when it fails to pull api data', function() {
        var button, options;
        sinon.stub(head, "insertBefore", function() {
          return window.callback({
            meta: {
              status: 404
            }
          });
        });
        options = {
          data: {
            count: {
              api: "/dummy/api#followers",
              aria: {}
            }
          },
          aria: {}
        };
        new ButtonFrameContent(options);
        expect(document.body.appendChild).to.be.calledOnce;
        button = document.body.appendChild.args[0][0];
        expect(button).to.have.property("className").and.equal("button");
        return head.insertBefore.restore();
      });
    });
  });

}).call(this);
